class GitHubAudit {
    constructor() {
        // üî¥ REPLACE WITH NEW TOKEN AFTER REVOKING OLD ONE
        this.GITHUB_TOKEN = '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';
        
        // ‚úÖ Your repository
        this.REPO = 'mandiyandiyakhonyana-blip/license-audit-logs';
        
        // ‚ö†Ô∏è CORRECT URL for GitHub Pages
        this.REVOCATION_URL = 'https://mandiyandiyakhonyana-blip.github.io/license-audit-logs/revoked.json';
        
        // Your public key (you need to generate this)
        this.PUBLIC_KEY = `-----BEGIN PUBLIC KEY-----
MCowBQYDK2VwAyEA6lK21P6StzPdhSdPn2cMaWXH/4FgE7tNxd8DwsGFycU=
-----END PUBLIC KEY-----`;
    }
    
    async logActivation(licenseKey, deviceId, action, metadata = {}) {
        // üî¥ FIRST REVOKE THE TOKEN BEFORE USING THIS CODE
        if (this.GITHUB_TOKEN.includes('github_pat_11BZQEJEQ')) {
            console.error('STOP: Using revoked token! Generate new one.');
            return;
        }
        
        try {
            const issueTitle = `${action}: ${this.maskLicense(licenseKey)}`;
            const issueBody = this.formatAuditBody(licenseKey, deviceId, action, metadata);
            
            const response = await fetch(`https://api.github.com/repos/${this.REPO}/issues`, {
                method: 'POST',
                headers: this.getHeaders(),
                body: JSON.stringify({
                    title: issueTitle,
                    body: issueBody,
                    labels: this.getLabels(action)
                })
            });
            
            return await this.handleResponse(response);
            
        } catch (error) {
            this.safeLog('Audit logging failed:', error.message);
            return { success: false, error: error.message };
        }
    }
    
    async checkRevocation(licenseKey) {
        try {
            // Add cache busting
            const url = `${this.REVOCATION_URL}?t=${Date.now()}&v=1`;
            const response = await fetch(url, { 
                cache: 'no-store',
                headers: { 'Pragma': 'no-cache', 'Cache-Control': 'no-cache' }
            });
            
            if (!response.ok) {
                // If we can't fetch revocation list, assume not revoked
                return false;
            }
            
            const data = await response.json();
            
            // Basic verification (in production, use proper crypto)
            if (!data.data || !data.signature) {
                return false;
            }
            
            // Check if license is in revoked list
            const revokedList = JSON.parse(data.data);
            const isRevoked = revokedList.includes(licenseKey);
            
            if (isRevoked) {
                await this.logActivation(licenseKey, 'unknown', 'revoked_access_attempt');
            }
            
            return isRevoked;
            
        } catch (error) {
            // Fail open - if we can't check, allow access
            console.warn('Revocation check failed:', error.message);
            return false;
        }
    }
    
    // Helper methods
    maskLicense(licenseKey) {
        if (!licenseKey || licenseKey.length < 8) return '***';
        return `${licenseKey.substring(0, 4)}...${licenseKey.substring(licenseKey.length - 4)}`;
    }
    
    formatAuditBody(licenseKey, deviceId, action, metadata) {
        return `
## üìã Activation Audit Log

### üîê License Information
- **License**: \`${this.maskLicense(licenseKey)}\`
- **Device ID**: \`${deviceId ? deviceId.substring(0, 16) + '...' : 'unknown'}\`
- **Action**: \`${action}\`

### ‚è∞ Timestamps
- **Event Time**: ${new Date().toISOString()}
- **Local Time**: ${new Date().toString()}

### üåê Environment
- **User Agent**: \`${navigator.userAgent.substring(0, 100)}...\`
- **Platform**: ${navigator.platform}
- **Languages**: ${navigator.languages ? navigator.languages.join(', ') : 'unknown'}

### üìä Additional Data
\`\`\`json
${JSON.stringify(metadata, null, 2)}
\`\`\`

---
*Generated by Zendesk Macro CC/BCC Extension*
`.trim();
    }
    
    getHeaders() {
        return {
            'Authorization': `Bearer ${this.GITHUB_TOKEN}`,
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json',
            'X-GitHub-Api-Version': '2022-11-28'
        };
    }
    
    getLabels(action) {
        const baseLabels = ['audit', 'extension'];
        
        if (action.includes('revoked')) {
            baseLabels.push('security', 'revoked');
        } else if (action.includes('activated')) {
            baseLabels.push('success', 'activation');
        } else if (action.includes('attempt')) {
            baseLabels.push('attempt');
        }
        
        return baseLabels;
    }
    
    async handleResponse(response) {
        if (response.status === 201) {
            const data = await response.json();
            return { 
                success: true, 
                issueUrl: data.html_url,
                issueNumber: data.number 
            };
        } else if (response.status === 401 || response.status === 403) {
            console.error('GitHub token invalid or expired');
            return { success: false, error: 'Authentication failed' };
        } else {
            const errorText = await response.text();
            console.warn('GitHub API error:', response.status, errorText);
            return { success: false, error: `HTTP ${response.status}` };
        }
    }
    
    safeLog(...args) {
        // Don't log tokens in production
        const sanitized = args.map(arg => 
            typeof arg === 'string' 
                ? arg.replace(/github_pat_[A-Za-z0-9_]+/g, '[TOKEN]')
                : arg
        );
        console.warn(...sanitized);
    }
}

// Singleton instance
if (!window.githubAudit) {
    window.githubAudit = new GitHubAudit();
}

// Export for module systems
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { GitHubAudit };
}
